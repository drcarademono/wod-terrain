using DaggerfallConnect.Arena2;
using DaggerfallConnect.Utility;
using DaggerfallWorkshop;
using System;
using System.Linq;
using Unity.Collections;
using UnityEngine;

namespace Monobelisk
{
    public static class BufferIO
    {
        const byte water = 0;
        const byte dirt = 1;
        const byte grass = 2;
        const byte stone = 3;

        /// <summary>
        /// Creates and inits a collection of ComputeBuffers for use with the Interesting Terrains terrain sampler.
        /// </summary>
        /// <returns></returns>
        public static HeightmapBufferCollection CreateHeightmapBuffers()
        {

            var heightmapRes = MapsFile.WorldMapTileDim + 1;
            var heightmapBuffer = new ComputeBuffer(heightmapRes * heightmapRes, sizeof(float));

            var rawNoiseRes = heightmapRes + 1;

            var rawNoise = new ComputeBuffer(rawNoiseRes * rawNoiseRes, sizeof(float));

            var tilemapData = new ComputeBuffer(heightmapRes * heightmapRes, sizeof(int));

            return new HeightmapBufferCollection()
            {
                heightmapBuffer = heightmapBuffer,
                rawNoise = rawNoise,
                tilemapData = tilemapData
            };
        }

        /// <summary>
        /// Extracts data from the ComputeBuffers, applies it to the terrain, then disposes of the buffers.
        /// </summary>
        /// <param name="buffers"></param>
        /// <param name="mapData"></param>
        /// 
        public static void ProcessBufferValuesAndDispose(HeightmapBufferCollection buffers, ref MapPixelData mapData)
        {
            // Extract heights, generated by TerrainComputer, as float array
            var heightValues = new float[buffers.heightmapBuffer.count];
            buffers.heightmapBuffer.GetData(heightValues);

            // Assign generated heights to mapData
            CopyToNative(heightValues, ref mapData.heightmapData);
            mapData.heightmapSamples = To2D(mapData.heightmapData, HeightmapRes());

            // Extract tileData, generated by TerrainComputer, as int array
            int res = MapsFile.WorldMapTileDim + 1;
            var tilemapInts = new int[res * res];
            buffers.tilemapData.GetData(tilemapInts);

            // Convert to byte array
            var tileData = tilemapInts.Select(v => AsByte(v)).ToArray();

            // Add to internal tileData storage for use in TerrainTexturer
            var pos = new DFPosition(mapData.mapPixelX, mapData.mapPixelY);
            InterestingTerrains.tileDataCache.Add(pos, tileData);

            // Cleanup
            buffers.Dispose();
        }

        private static byte AsByte(int val)
        {
            switch (val)
            {
                case 0:
                    return water;
                case 1:
                    return dirt;
                case 2:
                    return grass;
                case 3:
                    return stone;
                default:
                    return grass;
            }
        }

        private static void CopyToNative(float[] source, ref NativeArray<float> target)
        {
            int sourceSize = (int)Mathf.Sqrt(source.Length); // e.g., 33 if heightmapResolution is 32
            int targetSize = (int)Mathf.Sqrt(target.Length); // e.g., 129 if heightmapResolution is 128

            Debug.Log($"CopyToNative using Compute Shader. Source size: {sourceSize}x{sourceSize}, Target size: {targetSize}x{targetSize}");

            // Ensure the compute shader is loaded
            ComputeShader computeShader = InterestingTerrains.interpolateHeightmapShader;
            if (computeShader == null)
            {
                Debug.LogError("Failed to access TerrainComputer compute shader. Ensure it's correctly loaded.");
                return;
            }

            // Initialize ComputeBuffers
            ComputeBuffer sourceBuffer = new ComputeBuffer(source.Length, sizeof(float));
            ComputeBuffer targetBuffer = new ComputeBuffer(target.Length, sizeof(float));

            // Set data to the source buffer
            sourceBuffer.SetData(source);

            // Set shader parameters
            int kernel = computeShader.FindKernel("InterpolateHeightmap");
            if (kernel < 0)
            {
                Debug.LogError("Failed to find kernel 'InterpolateHeightmap' in compute shader.");
                sourceBuffer.Dispose();
                targetBuffer.Dispose();
                return;
            }

            computeShader.SetBuffer(kernel, "sourceHeightmap", sourceBuffer);
            computeShader.SetBuffer(kernel, "targetHeightmap", targetBuffer);
            computeShader.SetInt("resolution", targetSize); // Use target size as both source and target have the same resolution
            computeShader.SetInt("sourceSize", sourceSize);
            computeShader.SetInt("targetSize", targetSize);

            // Dispatch shader
            int threadGroupSize = 8;
            computeShader.Dispatch(kernel, Mathf.CeilToInt((float)targetSize / threadGroupSize), Mathf.CeilToInt((float)targetSize / threadGroupSize), 1);

            // Retrieve data from target buffer
            float[] tempTarget = new float[target.Length];
            targetBuffer.GetData(tempTarget);

            // Copy data to the NativeArray
            for (int i = 0; i < target.Length; i++)
            {
                target[i] = tempTarget[i];
            }

            // Cleanup
            sourceBuffer.Dispose();
            targetBuffer.Dispose();

            Debug.Log("CopyToNative completed successfully using Compute Shader.");
        }

        private static float[,] To2D(NativeArray<float> values, int res)
        {
            ValidateLength(values, res);
            //var res = HeightmapRes();
            var result = new float[res, res];

            for (int x = 0; x < res; x++)
            {
                for (int y = 0; y < res; y++)
                {
                    int i = y + x * res;
                    result[x, y] = values[i];
                }
            }

            return result;
        }


        private static int HeightmapRes()
        {
            return (int)InterestingTerrains.settings.heightmapResolution;
        }

        private static void ValidateLength(NativeArray<float> values, int res)
        {
            if (values.Length != res * res)
            {
                throw new Exception
                (
                    String.Format("Array length is {0}, should be {1}", values.Length, res * res)
                );
            }
        }
    }
}
