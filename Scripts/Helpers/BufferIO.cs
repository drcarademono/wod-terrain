using DaggerfallConnect.Arena2;
using DaggerfallConnect.Utility;
using DaggerfallWorkshop;
using System;
using System.Linq;
using Unity.Collections;
using UnityEngine;

namespace Monobelisk
{
    public static class BufferIO
    {
        const byte water = 0;
        const byte dirt = 1;
        const byte grass = 2;
        const byte stone = 3;

        /// <summary>
        /// Creates and inits a collection of ComputeBuffers for use with the Interesting Terrains terrain sampler.
        /// </summary>
        /// <returns></returns>
        public static HeightmapBufferCollection CreateHeightmapBuffers()
        {

            var heightmapRes = MapsFile.WorldMapTileDim + 1;
            var heightmapBuffer = new ComputeBuffer(heightmapRes * heightmapRes, sizeof(float));

            var rawNoiseRes = heightmapRes + 1;

            var rawNoise = new ComputeBuffer(rawNoiseRes * rawNoiseRes, sizeof(float));

            var tilemapData = new ComputeBuffer(heightmapRes * heightmapRes, sizeof(int));

            return new HeightmapBufferCollection()
            {
                heightmapBuffer = heightmapBuffer,
                rawNoise = rawNoise,
                tilemapData = tilemapData
            };
        }

        /// <summary>
        /// Extracts data from the ComputeBuffers, applies it to the terrain, then disposes of the buffers.
        /// </summary>
        /// <param name="buffers"></param>
        /// <param name="mapData"></param>
        /// 
        public static void ProcessBufferValuesAndDispose(HeightmapBufferCollection buffers, ref MapPixelData mapData)
        {
            // Extract heights, generated by TerrainComputer, as float array
            var heightValues = new float[buffers.heightmapBuffer.count];
            buffers.heightmapBuffer.GetData(heightValues);

            // Assign generated heights to mapData
            CopyToNative(heightValues, ref mapData.heightmapData);
            mapData.heightmapSamples = To2D(mapData.heightmapData, HeightmapRes());

            // Extract tileData, generated by TerrainComputer, as int array
            int res = MapsFile.WorldMapTileDim + 1;
            var tilemapInts = new int[res * res];
            buffers.tilemapData.GetData(tilemapInts);

            // Convert to byte array
            var tileData = tilemapInts.Select(v => AsByte(v)).ToArray();

            // Add to internal tileData storage for use in TerrainTexturer
            var pos = new DFPosition(mapData.mapPixelX, mapData.mapPixelY);
            InterestingTerrains.tileDataCache.Add(pos, tileData);

            // Cleanup
            buffers.Dispose();
        }

        private static byte AsByte(int val)
        {
            switch (val)
            {
                case 0:
                    return water;
                case 1:
                    return dirt;
                case 2:
                    return grass;
                case 3:
                    return stone;
                default:
                    return grass;
            }
        }

        private static void CopyToNative(float[] source, ref NativeArray<float> target)
        {
            int sourceSize = (int)Mathf.Sqrt(source.Length); // e.g., 33 if heightmapResolution is 32
            int targetSize = (int)Mathf.Sqrt(target.Length); // e.g., 129 if heightmapResolution is 128
            int step = 4; // We calculate every 4th index

            Debug.Log($"CopyToNative called. Source size: {sourceSize}x{sourceSize}, Target size: {targetSize}x{targetSize}");

            // Copy every 4th index
            for (int y = 0; y < sourceSize; y++)
            {
                for (int x = 0; x < sourceSize; x++)
                {
                    if (x % step == 0 && y % step == 0)
                    {
                        target[y * targetSize + x] = source[y * sourceSize + x];
                    }
                }
            }

            // Interpolate the remaining indices
            for (int y = 0; y < targetSize; y++)
            {
                for (int x = 0; x < targetSize; x++)
                {
                    if (x % step != 0 || y % step != 0)
                    {
                        target[y * targetSize + x] = InterpolateValue(target, targetSize, x, y, step);
                    }
                }
            }
        }

        private static float InterpolateValue(NativeArray<float> target, int targetSize, int x, int y, int step)
        {
            // Find the nearest calculated indices
            int x0 = (x / step) * step;
            int x1 = Mathf.Clamp(x0 + step, 0, targetSize - 1);
            int y0 = (y / step) * step;
            int y1 = Mathf.Clamp(y0 + step, 0, targetSize - 1);

            // Calculate interpolation weights
            float tx = (float)(x - x0) / step;
            float ty = (float)(y - y0) / step;

            // Fetch the four nearest calculated values
            float c00 = target[y0 * targetSize + x0];
            float c10 = target[y0 * targetSize + x1];
            float c01 = target[y1 * targetSize + x0];
            float c11 = target[y1 * targetSize + x1];

            // Perform bilinear interpolation
            return Mathf.Lerp(
                Mathf.Lerp(c00, c10, tx),
                Mathf.Lerp(c01, c11, tx),
                ty
            );
        }

        private static float[,] To2D(NativeArray<float> values, int res)
        {
            ValidateLength(values, res);
            //var res = HeightmapRes();
            var result = new float[res, res];

            for (int x = 0; x < res; x++)
            {
                for (int y = 0; y < res; y++)
                {
                    int i = y + x * res;
                    result[x, y] = values[i];
                }
            }

            return result;
        }


        private static int HeightmapRes()
        {
            return (int)InterestingTerrains.settings.heightmapResolution;
        }

        private static void ValidateLength(NativeArray<float> values, int res)
        {
            if (values.Length != res * res)
            {
                throw new Exception
                (
                    String.Format("Array length is {0}, should be {1}", values.Length, res * res)
                );
            }
        }
    }
}
