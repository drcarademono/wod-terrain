using DaggerfallConnect.Arena2;
using DaggerfallConnect.Utility;
using DaggerfallWorkshop;
using System;
using System.Linq;
using Unity.Collections;
using UnityEngine;

namespace Monobelisk
{
    public static class BufferIO
    {
        const byte water = 0;
        const byte dirt = 1;
        const byte grass = 2;
        const byte stone = 3;

        /// <summary>
        /// Creates and inits a collection of ComputeBuffers for use with the Interesting Terrains terrain sampler.
        /// </summary>
        /// <returns></returns>
        public static HeightmapBufferCollection CreateHeightmapBuffers()
        {

            var heightmapRes = MapsFile.WorldMapTileDim + 1;
            var heightmapBuffer = new ComputeBuffer(heightmapRes * heightmapRes, sizeof(float));

            var rawNoiseRes = heightmapRes + 1;

            var rawNoise = new ComputeBuffer(rawNoiseRes * rawNoiseRes, sizeof(float));

            var tilemapData = new ComputeBuffer(heightmapRes * heightmapRes, sizeof(int));

            return new HeightmapBufferCollection()
            {
                heightmapBuffer = heightmapBuffer,
                rawNoise = rawNoise,
                tilemapData = tilemapData
            };
        }

        /// <summary>
        /// Extracts data from the ComputeBuffers, applies it to the terrain, then disposes of the buffers.
        /// </summary>
        /// <param name="buffers"></param>
        /// <param name="mapData"></param>
        /// 
        public static void ProcessBufferValuesAndDispose(HeightmapBufferCollection buffers, ref MapPixelData mapData)
        {
            // Extract heights, generated by TerrainComputer, as float array
            var heightValues = new float[buffers.heightmapBuffer.count];
            buffers.heightmapBuffer.GetData(heightValues);

            // Assign generated heights to mapData
            CopyToNative(heightValues, ref mapData.heightmapData);
            mapData.heightmapSamples = To2D(mapData.heightmapData, HeightmapRes());

            // Extract tileData, generated by TerrainComputer, as int array
            int res = MapsFile.WorldMapTileDim + 1;
            var tilemapInts = new int[res * res];
            buffers.tilemapData.GetData(tilemapInts);

            // Convert to byte array
            var tileData = tilemapInts.Select(v => AsByte(v)).ToArray();

            // Add to internal tileData storage for use in TerrainTexturer
            var pos = new DFPosition(mapData.mapPixelX, mapData.mapPixelY);
            InterestingTerrains.tileDataCache.Add(pos, tileData);

            // Cleanup
            buffers.Dispose();
        }

        private static byte AsByte(int val)
        {
            switch (val)
            {
                case 0:
                    return water;
                case 1:
                    return dirt;
                case 2:
                    return grass;
                case 3:
                    return stone;
                default:
                    return grass;
            }
        }

        private static void CopyToNative(float[] source, ref NativeArray<float> target)
        {
            for(int i = 0; i < target.Length; i++)
            {
                target[i] = source[i];
            }
        }

        private static float[,] To2D(NativeArray<float> values, int res)
        {
            ValidateLength(values, res);
            //var res = HeightmapRes();
            var result = new float[res, res];

            for (int x = 0; x < res; x++)
            {
                for (int y = 0; y < res; y++)
                {
                    int i = y + x * res;
                    result[x, y] = values[i];
                }
            }

            return result;
        }


        private static int HeightmapRes()
        {
            return (int)InterestingTerrains.settings.heightmapResolution;
        }

        private static void ValidateLength(NativeArray<float> values, int res)
        {
            if (values.Length != res * res)
            {
                throw new Exception
                (
                    String.Format("Array length is {0}, should be {1}", values.Length, res * res)
                );
            }
        }
    }
}