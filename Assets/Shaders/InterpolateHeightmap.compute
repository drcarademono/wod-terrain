// InterpolateHeightmap.compute
#pragma kernel InterpolateHeightmap

RWStructuredBuffer<float> sourceHeightmap;
RWStructuredBuffer<float> targetHeightmap;
int resolution; // Both source and target resolution
int mode;       // 0 for bilinear, 1 for bicubic

// Optimized cubic interpolation using Catmull-Rom spline coefficients
float CubicInterpolateOptimized(float p0, float p1, float p2, float p3, float t)
{
    float a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;
    float b = p0 - 2.5 * p1 + 2.0 * p2 - 0.5 * p3;
    float c = -0.5 * p0 + 0.5 * p2;
    return ((a * t + b) * t + c) * t + p1;
}

[numthreads(8, 8, 1)]
void InterpolateHeightmap(uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;

    // Skip out-of-bounds threads
    if (x >= resolution || y >= resolution) return;

    // Copy precomputed values for multiples of 4
    if ((x % 4 == 0) && (y % 4 == 0))
    {
        targetHeightmap[y * resolution + x] = sourceHeightmap[y * resolution + x];
        return;
    }

    // Identify the nearest valid indices for interpolation
    int x0 = max((x / 4) * 4, 0);                  // Nearest multiple of 4 to the left
    int x1 = min(x0 + 4, resolution - 1);          // Nearest multiple of 4 to the right
    int y0 = max((y / 4) * 4, 0);                  // Nearest multiple of 4 above
    int y1 = min(y0 + 4, resolution - 1);          // Nearest multiple of 4 below

    if (mode == 0)
    {
        // Bilinear interpolation
        float tx = x1 == x0 ? 0.0 : float(x - x0) / float(x1 - x0); // Horizontal weight
        float ty = y1 == y0 ? 0.0 : float(y - y0) / float(y1 - y0); // Vertical weight

        float c00 = sourceHeightmap[y0 * resolution + x0]; // Top-left
        float c10 = sourceHeightmap[y0 * resolution + x1]; // Top-right
        float c01 = sourceHeightmap[y1 * resolution + x0]; // Bottom-left
        float c11 = sourceHeightmap[y1 * resolution + x1]; // Bottom-right

        targetHeightmap[y * resolution + x] = lerp(
            lerp(c00, c10, tx), // Horizontal interpolation (top row)
            lerp(c01, c11, tx), // Horizontal interpolation (bottom row)
            ty                  // Vertical interpolation
        );
    }
    else if (mode == 1)
    {
        // Bicubic interpolation
        int xNeg = max(x0 - 4, 0);
        int xPos = min(x1 + 4, resolution - 1);
        int yNeg = max(y0 - 4, 0);
        int yPos = min(y1 + 4, resolution - 1);

        float tx = x1 == x0 ? 0.0 : float(x - x0) / float(x1 - x0); // Horizontal weight
        float ty = y1 == y0 ? 0.0 : float(y - y0) / float(y1 - y0); // Vertical weight

        float row0 = CubicInterpolateOptimized(
            sourceHeightmap[yNeg * resolution + xNeg],
            sourceHeightmap[yNeg * resolution + x0],
            sourceHeightmap[yNeg * resolution + x1],
            sourceHeightmap[yNeg * resolution + xPos],
            tx
        );

        float row1 = CubicInterpolateOptimized(
            sourceHeightmap[y0 * resolution + xNeg],
            sourceHeightmap[y0 * resolution + x0],
            sourceHeightmap[y0 * resolution + x1],
            sourceHeightmap[y0 * resolution + xPos],
            tx
        );

        float row2 = CubicInterpolateOptimized(
            sourceHeightmap[y1 * resolution + xNeg],
            sourceHeightmap[y1 * resolution + x0],
            sourceHeightmap[y1 * resolution + x1],
            sourceHeightmap[y1 * resolution + xPos],
            tx
        );

        float row3 = CubicInterpolateOptimized(
            sourceHeightmap[yPos * resolution + xNeg],
            sourceHeightmap[yPos * resolution + x0],
            sourceHeightmap[yPos * resolution + x1],
            sourceHeightmap[yPos * resolution + xPos],
            tx
        );

        targetHeightmap[y * resolution + x] = CubicInterpolateOptimized(row0, row1, row2, row3, ty);
    }
}

