// InterpolateHeightmap.compute
#pragma kernel InterpolateHeightmap

RWStructuredBuffer<float> sourceHeightmap;
RWStructuredBuffer<float> targetHeightmap;
int resolution; // Both source and target resolution
int mode;       // 0 for bilinear, 1 for bicubic
int terrainStep;

// Optimized cubic interpolation using Catmull-Rom spline coefficients
float CubicInterpolateOptimized(float p0, float p1, float p2, float p3, float t)
{
    float a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;
    float b = p0 - 2.5 * p1 + 2.0 * p2 - 0.5 * p3;
    float c = -0.5 * p0 + 0.5 * p2;
    return ((a * t + b) * t + c) * t + p1;
}

[numthreads(8, 8, 1)]
void InterpolateHeightmap(uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;

    // Skip out-of-bounds threads
    if (x >= resolution || y >= resolution) return;

    // Copy precomputed values for multiples of terrainStep
    if ((x % terrainStep == 0) && (y % terrainStep == 0))
    {
        targetHeightmap[y * resolution + x] = sourceHeightmap[y * resolution + x];
        return;
    }

    // Identify the nearest valid indices for interpolation
    int x0 = max((x / terrainStep) * terrainStep, 0);                  // Nearest multiple of 4 to the left
    int x1 = min(x0 + terrainStep, resolution - 1);          // Nearest multiple of 4 to the right
    int y0 = max((y / terrainStep) * terrainStep, 0);                  // Nearest multiple of 4 above
    int y1 = min(y0 + terrainStep, resolution - 1);          // Nearest multiple of 4 below

    if (mode == 0) // Optimized bilinear interpolation
    {
        // Prevent division by zero for edge cases
        float tx = (x1 == x0) ? 0.0 : float(x - x0) / float(x1 - x0);
        float ty = (y1 == y0) ? 0.0 : float(y - y0) / float(y1 - y0);

        // Fetch the four nearest precomputed values with boundary checks
        float c00 = (x0 >= 0 && y0 >= 0) ? sourceHeightmap[y0 * resolution + x0] : 0.0;
        float c10 = (x1 < resolution && y0 >= 0) ? sourceHeightmap[y0 * resolution + x1] : 0.0;
        float c01 = (x0 >= 0 && y1 < resolution) ? sourceHeightmap[y1 * resolution + x0] : 0.0;
        float c11 = (x1 < resolution && y1 < resolution) ? sourceHeightmap[y1 * resolution + x1] : 0.0;

        // Perform bilinear interpolation
        targetHeightmap[y * resolution + x] =
            c00 * (1.0 - tx) * (1.0 - ty) +
            c10 * tx * (1.0 - ty) +
            c01 * (1.0 - tx) * ty +
            c11 * tx * ty;
    }
    else if (mode == 1)
    {
        // Bicubic interpolation
        int xNeg = max(x0 - terrainStep, 0);
        int xPos = min(x1 + terrainStep, resolution - 1);
        int yNeg = max(y0 - terrainStep, 0);
        int yPos = min(y1 + terrainStep, resolution - 1);

        float tx = x1 == x0 ? 0.0 : float(x - x0) / float(x1 - x0); // Horizontal weight
        float ty = y1 == y0 ? 0.0 : float(y - y0) / float(y1 - y0); // Vertical weight

        float row0 = CubicInterpolateOptimized(
            sourceHeightmap[yNeg * resolution + xNeg],
            sourceHeightmap[yNeg * resolution + x0],
            sourceHeightmap[yNeg * resolution + x1],
            sourceHeightmap[yNeg * resolution + xPos],
            tx
        );

        float row1 = CubicInterpolateOptimized(
            sourceHeightmap[y0 * resolution + xNeg],
            sourceHeightmap[y0 * resolution + x0],
            sourceHeightmap[y0 * resolution + x1],
            sourceHeightmap[y0 * resolution + xPos],
            tx
        );

        float row2 = CubicInterpolateOptimized(
            sourceHeightmap[y1 * resolution + xNeg],
            sourceHeightmap[y1 * resolution + x0],
            sourceHeightmap[y1 * resolution + x1],
            sourceHeightmap[y1 * resolution + xPos],
            tx
        );

        float row3 = CubicInterpolateOptimized(
            sourceHeightmap[yPos * resolution + xNeg],
            sourceHeightmap[yPos * resolution + x0],
            sourceHeightmap[yPos * resolution + x1],
            sourceHeightmap[yPos * resolution + xPos],
            tx
        );

        targetHeightmap[y * resolution + x] = CubicInterpolateOptimized(row0, row1, row2, row3, ty);
    }
}

